# Network Policy and DaemonSet

This document covers Kubernetes Network Policies and DaemonSets with practical examples and explanations.

## Network Policy

### Overview
- **Purpose**: Controls traffic flow between pods and external endpoints
- **Default Behavior**: All pods in a cluster can communicate with each other (flat network)
- **Requirements**: Needs a network plugin (Calico, Cilium, Weave, etc.)
- **Security Model**: Enables zero-trust networking

### Basic Network Policy from Kubernetes Documentation

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db  # Applies policy to pods with label: role=db
  policyTypes:
  - Ingress  # Controls incoming traffic
  - Egress   # Controls outgoing traffic
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16  # Allow traffic from this CIDR block
        except:
        - 172.17.1.0/24      # Except this subnet
    # OR allow from specific namespaces
    - namespaceSelector:
        matchLabels:
          project: myproject
    # AND allow from specific pods
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 6379  # Allow only port 6379
  egress:
  - to:
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 5432
```

### Real-World Network Policy Example

This example demonstrates namespace-level network isolation:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: prod-network-policy
  namespace: prod
spec:
  podSelector:
    matchLabels:
      name: prodone  # Policy applies only to pods labeled "name: prodone"
  policyTypes:
  - Ingress  # Only control incoming traffic
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: dev  # Allow traffic from dev namespace
      podSelector:
        matchLabels:
          name: devone  # Only from pods labeled "name: devone"
    ports:
    - protocol: TCP
      port: 80  # Allow only HTTP traffic
```

### Network Policy Workflow Commands

#### 1. Label Namespaces
```bash
# Namespaces must have labels to be used in network policy selectors
kubectl label namespace dev kubernetes.io/metadata.name=dev
kubectl label namespace test kubernetes.io/metadata.name=test
kubectl label namespace prod kubernetes.io/metadata.name=prod
```

#### 2. Create Test Pods in Different Namespaces
```bash
# Deploy pods with specific labels in each namespace
kubectl -n dev apply -f devone.yaml
kubectl -n test apply -f testone.yaml
kubectl -n prod apply -f prodone.yaml
```

#### 3. Check Connectivity Before Policy
```bash
# Before network policy: all pods can communicate across namespaces
# Test dev pod accessing prod pod
kubectl -n dev exec devone -- curl http://172.17.235.138
# Result: Success (200 OK)

# Test test pod accessing prod pod
kubectl -n test exec testone -- curl http://172.17.235.138
# Result: Success (200 OK)
```

#### 4. Apply Network Policy
```bash
# Restrict prod namespace to only accept traffic from dev namespace
kubectl apply -f prod-network-policy.yaml

# Verify network policy was created
kubectl -n prod get networkpolicy
kubectl -n prod describe networkpolicy prod-network-policy
```

#### 5. Test Connectivity After Policy
```bash
# After applying network policy:
# Test dev pod accessing prod pod - ALLOWED
kubectl -n dev exec devone -- curl http://172.17.235.138
# Result: Success (200 OK) - Allowed by network policy

# Test test pod accessing prod pod - BLOCKED
kubectl -n test exec testone -- curl http://172.17.235.138
# Result: Timeout/Connection refused - Blocked by network policy
```

#### 6. Cleanup
```bash
# Remove network policy
kubectl delete -f prod-network-policy.yaml

# Verify it's removed
kubectl -n prod get networkpolicy
```

### Network Policy Management Commands Summary

```bash
# List network policies in a namespace
kubectl get networkpolicy -n prod
kubectl get netpol -n prod

# Describe a specific network policy
kubectl -n prod describe networkpolicy prod-network-policy

# Check all network policies cluster-wide
kubectl get networkpolicy --all-namespaces

# Delete network policy
kubectl delete networkpolicy prod-network-policy -n prod
```

---

## DaemonSet

### Overview
- **Purpose**: Ensures a copy of a pod runs on every node in the cluster
- **Comparison**: Better than Deployments for node-level operations
- **Key Difference**: Cannot specify replicas (runs automatically on all nodes)
- **Common Use Cases**: Logging, monitoring, networking, security agents

### DaemonSet Example: Fluentd Elasticsearch

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system  # System namespace for logging
  labels:
    k8s-app: fluentd-logging
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch  # Pods created from this template
  template:
    metadata:
      labels:
        name: fluentd-elasticsearch  # Pod labels for selector matching
    spec:
      # Tolerations allow daemonset to run on control plane nodes
      tolerations:
      # Remove these if control plane nodes shouldn't run pods
      - key: node-role.kubernetes.io/control-plane
        operator: Exists      # Tolerate the taint (allow scheduling)
        effect: NoSchedule    # Tolerate this NoSchedule effect
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      
      containers:
      - name: fluentd-elasticsearch
        image: quay.io/fluentd_elasticsearch/fluentd:v5.0.1  # Fluentd image
        
        # Resource limits and requests
        resources:
          limits:
            memory: 200Mi        # Maximum memory allowed
          requests:
            cpu: 100m           # CPU request (guaranteed minimum)
            memory: 200Mi       # Memory request (guaranteed minimum)
        
        # Mount host volume into container
        volumeMounts:
        - name: varlog
          mountPath: /var/log  # Container path
      
      # Time to gracefully shutdown before forceful termination
      terminationGracePeriodSeconds: 30
      
      # Define volumes to use in the pod
      volumes:
      - name: varlog
        hostPath:
          path: /var/log  # Host machine's /var/log directory
```

### DaemonSet Workflow Commands

#### 1. Check Nodes in Cluster
```bash
# View all nodes where daemonsets will run
kubectl get nodes
kubectl get nodes -o wide
```

#### 2. View System DaemonSets
```bash
# DaemonSets commonly run in kube-system namespace
kubectl -n kube-system get daemonsets
kubectl -n kube-system get ds

# Example: Check Calico daemonset
kubectl get pods -n kube-system | grep calico
```

#### 3. Monitor DaemonSet Pod Deployment
```bash
# Get pods created by daemonset
kubectl -n kube-system get pods -o wide -l k8s-app=calico-node

# Watch pods in real-time (shows status changes as they happen)
kubectl -n kube-system get pods -l k8s-app=calico-node -w

# Wait for all pods to be ready with timeout
kubectl wait --for=condition=ready pod -l k8s-app=calico-node -n kube-system --timeout=120s
```

#### 4. Manage DaemonSet Pods
```bash
# Delete daemonset pods (they'll be automatically recreated by daemonset controller)
kubectl delete pods -n kube-system -l k8s-app=calico-node

# Force delete stuck pods
kubectl delete pod app -n dev --force --grace-period=0
```

### DaemonSet Management Commands Summary

```bash
# List daemonsets in a namespace
kubectl -n kube-system get daemonsets
kubectl -n kube-system get ds

# Describe a daemonset
kubectl describe daemonset fluentd-elasticsearch -n kube-system

# Check pod logs from daemonset
kubectl logs -f fluentd-elasticsearch-xxxxx -n kube-system

# Update daemonset (e.g., change image)
kubectl set image daemonset/fluentd-elasticsearch fluentd-elasticsearch=new-image:tag -n kube-system
```

---

## Comparison: DaemonSet vs Deployment

| Feature | DaemonSet | Deployment |
|---------|-----------|-----------|
| **Replicas** | Runs on every node (automatic) | Manual/configurable |
| **Purpose** | Node-level operations | Application deployment |
| **Scaling** | Automatic with cluster growth | Manual or HPA |
| **Pod Count** | Nodes count | Configurable replica count |
| **Typical Use** | Logging, monitoring, networking | Web servers, databases |
| **High Availability** | Redundant across nodes | Configurable replicas |

---

## Troubleshooting Tips

### Network Policy Issues
```bash
# Verify namespaces have required labels
kubectl get ns --show-labels

# Check if network plugin is installed and running
kubectl get pods -n kube-system | grep -E 'calico|cilium|weave'

# Verify network policy exists
kubectl describe networkpolicy -n prod

# Check pod labels match selectors
kubectl get pods -n prod --show-labels
```

### DaemonSet Issues
```bash
# Check daemonset status
kubectl describe ds fluentd-elasticsearch -n kube-system

# View pod events for errors
kubectl get events -n kube-system --sort-by='.lastTimestamp'

# Check logs of failed pods
kubectl logs -p fluentd-elasticsearch-xxxxx -n kube-system

# Verify node selectors/tolerations
kubectl describe node worker1 | grep -A5 Taints
```

---

## Key Takeaways

### Network Policies
- Enable microservices security through pod-level firewall rules
- Default is allow-all; you must explicitly create policies for deny
- Require network plugin support (CNI)
- Use namespace selectors for cross-namespace policies

### DaemonSets
- Ensure services run on every node (or selected nodes)
- Auto-scale with cluster size
- Perfect for infrastructure concerns (logging, monitoring)
- Use tolerations to control node scheduling
