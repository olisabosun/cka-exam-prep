# Quality of Service (QoS) Classes in Kubernetes

Kubernetes uses Quality of Service (QoS) classes to prioritize pods during resource allocation and eviction. There are three QoS classes: BestEffort, Burstable, and Guaranteed.

## QoS Classes Overview

### 1. BestEffort
- **Description**: No CPU or memory requests/limits specified in the pod YAML
- **Behavior**: Kubernetes provides resources from leftovers; lowest priority
- **Use Case**: Development and test environments
- **Resource Allocation**: No guarantees, resources given as available

### 2. Burstable
- **Description**: CPU and memory requests defined, with limits higher than requests
- **Behavior**: Requests are guaranteed and allocated at pod startup; limits allow bursting when load increases
- **Use Case**: Applications with variable load patterns
- **Resource Allocation**: Guaranteed minimum (requests), can use more up to limits

### 3. Guaranteed
- **Description**: CPU and memory requests equal to limits
- **Behavior**: Highest priority pods with guaranteed resources
- **Use Case**: Critical applications requiring consistent performance
- **Resource Allocation**: Guaranteed resources equal to limits

## Burstable QoS Example

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: burst
  labels:
    name: nginx
spec:
  containers:
  - name: checkers
    image: nginx:1.14.2
    ports:
    - containerPort: 80
    resources:
      limits:
        cpu: 200m
        memory: 200Mi
      requests:
        cpu: 100m
        memory: 100Mi
```

**Verification Command:**
```bash
kubectl describe pods burst
```

**Expected Output (relevant sections):**
```
Limits:
  cpu:     200m
  memory:  200Mi
Requests:
  cpu:        100m
  memory:     100Mi
...
QoS Class: Burstable
```

## Guaranteed QoS Example

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: guaranteed
  labels:
    name: nginx
spec:
  containers:
  - name: checkers
    image: nginx:1.14.2
    ports:
    - containerPort: 80
    resources:
      limits:
        cpu: 200m
        memory: 200Mi
      requests:
        cpu: 200m
        memory: 200Mi
```

**Verification Command:**
```bash
kubectl describe pods guaranteed
```

**Expected Output (relevant sections):**
```
Limits:
  cpu:     200m
  memory:  200Mi
Requests:
  cpu:        200m
  memory:     200Mi
...
QoS Class: Guaranteed
```

## Monitoring Resource Usage

### Metrics Server Setup
To monitor resource usage with `kubectl top`, you need to install the Metrics Server.

**Installation:**
```bash
# Download and apply the metrics server manifest
kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml

# Or use a specific version
kubectl apply -f https://github.com/networknuts/kubernetes/blob/master/ch-02-pod-scheduling/metric-server.yaml
```

**Usage:**
```bash
kubectl top nodes
kubectl top pods
```

## Sample Applications

For examples of pods with resource constraints:

- **Pod with memory limits**: https://github.com/networknuts/kubernetes/blob/master/ch-01-pods-containers/pod-with-memory-exceed.yml

## Key Points

- **BestEffort**: No resource guarantees, lowest priority during resource contention
- **Burstable**: Guaranteed minimum resources with ability to burst, medium priority
- **Guaranteed**: Highest priority with full resource guarantees
- Always specify resource requests and limits for production workloads
- Use `kubectl describe pod <pod-name>` to check QoS class assignment
