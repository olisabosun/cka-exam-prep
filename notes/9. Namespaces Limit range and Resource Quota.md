# Kubernetes Namespaces, Limit Ranges, and Resource Quotas

This document covers Kubernetes resource isolation and management using namespaces, limit ranges, and resource quotas.

## Namespaces

### Overview
- **Definition**: Virtual fencing or "cluster within a cluster"
- **Purpose**: Provides isolation between different environments/applications
- **Scope**: Cluster-wide resource for logical separation

### Default Namespace
Kubernetes automatically creates several namespaces:
- `default` - Default namespace for objects without a specific namespace
- `kube-system` - Contains Kubernetes system components
- `kube-public` - Contains publicly readable resources
- `kube-node-lease` - Contains lease objects for node heartbeats

### Namespace Management Commands

#### List Namespaces
```bash
kubectl get ns
kubectl get namespaces
```

#### Create Namespaces
```bash
# Imperative creation
kubectl create ns dev
kubectl create ns test
kubectl create ns prod

# Declarative creation using YAML
kubectl apply -f namespace.yaml
```

#### Work with Resources in Specific Namespaces
```bash
# Apply resources to specific namespace
kubectl -n dev apply -f mypod.yaml
kubectl -n test apply -f mypod.yaml
kubectl -n prod apply -f mypod.yaml

# Get resources from specific namespace
kubectl -n dev get pods
kubectl -n test get pods
kubectl -n prod get pods

# Set default namespace for current context
kubectl config set-context --current --namespace=dev
```

### Namespace YAML Example

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev
  labels:
    name: dev
    environment: development
```

## Limit Ranges

### Overview
- **Purpose**: Define default resource limits and requests for pods/containers in a namespace
- **Scope**: Applies to individual pods and containers
- **Enforcement**: Automatically applied when pods are created without explicit limits

### Limit Range YAML Example

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-memory-limit-range
  namespace: dev
spec:
  limits:
  - default:          # Default limits applied if not specified
      cpu: 500m       # Default CPU limit
      memory: 512Mi   # Default memory limit
    defaultRequest:   # Default requests applied if not specified
      cpu: 200m       # Default CPU request
      memory: 256Mi   # Default memory request
    max:              # Maximum allowed limits
      cpu: 2          # Max CPU limit
      memory: 2Gi     # Max memory limit
    min:              # Minimum allowed requests
      cpu: 100m       # Min CPU request
      memory: 128Mi   # Min memory request
    type: Container   # Applies to containers
```

### Limit Range Management

```bash
# Create limit range
kubectl apply -f limitrange.yaml

# List limit ranges
kubectl get limitrange
kubectl get limitranges

# Describe limit range
kubectl describe limitrange cpu-memory-limit-range
```

## Resource Quotas

### Overview
- **Purpose**: Set aggregate resource limits for a namespace
- **Scope**: Applies to the entire namespace (all pods, services, etc.)
- **Types**: CPU, memory, storage, object counts

### Resource Quota YAML Example

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "4"        # Total CPU requests allowed
    requests.memory: 8Gi     # Total memory requests allowed
    limits.cpu: "8"          # Total CPU limits allowed
    limits.memory: 16Gi      # Total memory limits allowed
    pods: "20"               # Maximum number of pods
    services: "10"           # Maximum number of services
    persistentvolumeclaims: "5"  # Maximum PVCs
    configmaps: "10"         # Maximum configmaps
    secrets: "10"            # Maximum secrets
```

### Resource Quota Management

```bash
# Create resource quota
kubectl apply -f resourcequota.yaml

# List resource quotas
kubectl get resourcequota
kubectl get quota

# Check quota usage
kubectl describe resourcequota compute-quota
```

## Network Policies

### Overview
- **Purpose**: Control traffic flow between pods and external endpoints
- **Default Behavior**: All pods can communicate with all other pods (flat network)
- **Implementation**: Uses network plugins (Calico, Cilium, etc.)

### Cross-Namespace Communication Example

By default, namespaces don't provide network isolation. A pod in the `dev` namespace can access services in `prod`:

```bash
# From a pod in dev namespace, access prod application
kubectl -n dev exec -it app-pod -- curl http://172.17.189.70
```

### Network Policy YAML Example

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
  namespace: prod
spec:
  podSelector: {}  # Applies to all pods in namespace
  policyTypes:
  - Ingress        # Controls incoming traffic
  - Egress         # Controls outgoing traffic
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dev-to-prod
  namespace: prod
spec:
  podSelector:
    matchLabels:
      app: web
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: dev  # Allow traffic from dev namespace
    ports:
    - protocol: TCP
      port: 80
```

### Network Policy Management

```bash
# Create network policy
kubectl apply -f networkpolicy.yaml

# List network policies
kubectl get networkpolicy
kubectl get netpol

# Describe network policy
kubectl describe networkpolicy deny-all
```

## Best Practices

### Namespace Organization
1. Use namespaces to separate environments (dev, test, prod)
2. Use namespaces to separate teams or projects
3. Avoid using default namespace for production workloads

### Resource Management
1. **Always set resource limits** to prevent resource exhaustion
2. **Use LimitRanges** to enforce consistent resource allocation
3. **Set ResourceQuotas** to prevent namespace-level resource abuse
4. **Monitor resource usage** regularly

### Security Considerations
1. **Implement NetworkPolicies** for production namespaces
2. **Use RBAC** to control access to namespaces
3. **Regularly audit** namespace permissions and resource usage

## Common Issues and Troubleshooting

### Resource Quota Exceeded
```bash
# Check quota status
kubectl describe resourcequota compute-quota

# Check events for quota violations
kubectl get events --sort-by=.metadata.creationTimestamp
```

### Network Connectivity Issues
```bash
# Check network policies
kubectl get networkpolicy

# Test connectivity between pods
kubectl exec -it pod-in-dev -- curl pod-in-prod-service
```

